// package main

// import (
// 	"context"
// 	"errors"
// 	"fmt"
// 	"log"
// 	"strings"
// 	"testing"
// 	"time"
// )

// // Test data structure
// type TestData struct {
// 	Value       string
// 	StepResults map[string]string
// }

// // Mock step that can be configured to fail or succeed
// type mockStep struct {
// 	name            string
// 	compensateCalls int
// 	failUntilCall   int // Fail until this call number (0 = always succeed)
// 	err             error
// }

// func newMockStep(name string, failUntilCall int) *mockStep {
// 	return &mockStep{
// 		name:          name,
// 		failUntilCall: failUntilCall,
// 		err:           fmt.Errorf("mock error for %s", name),
// 	}
// }

// func (m *mockStep) toSagaStep() *SagaStep[TestData] {
// 	return &SagaStep[TestData]{
// 		Name: m.name,
// 		Execute: func(ctx context.Context, data *TestData) error {
// 			data.StepResults[m.name] = "executed"
// 			return nil
// 		},
// 		Compensate: func(ctx context.Context, data *TestData) error {
// 			m.compensateCalls++
// 			if m.failUntilCall > 0 && m.compensateCalls <= m.failUntilCall {
// 				return m.err
// 			}
// 			data.StepResults[m.name] = "compensated"
// 			return nil
// 		},
// 	}
// }

// // Test logger that captures output
// type testLogger struct {
// 	logs []string
// }

// func newTestLogger() *testLogger {
// 	return &testLogger{logs: make([]string, 0)}
// }

// func (t *testLogger) Printf(format string, v ...interface{}) {
// 	t.logs = append(t.logs, fmt.Sprintf(format, v...))
// }

// func (t *testLogger) contains(substr string) bool {
// 	for _, log := range t.logs {
// 		if strings.Contains(log, substr) {
// 			return true
// 		}
// 	}
// 	return false
// }

// func (t *testLogger) countContaining(substr string) int {
// 	count := 0
// 	for _, log := range t.logs {
// 		if strings.Contains(log, substr) {
// 			count++
// 		}
// 	}
// 	return count
// }

// // =====================================
// // Tests for RetryStrategy
// // =====================================

// func TestRetryStrategy_SuccessfulCompensation(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	// All compensations succeed on first try
// 	step1 := newMockStep("Step1", 0) // Never fails
// 	step2 := newMockStep("Step2", 0) // Never fails

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 		step2.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      3,
// 		InitialBackoff:  10 * time.Millisecond,
// 		MaxBackoff:      100 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewRetryStrategy[TestData](config)

// 	// Simulate failure at step index 2, so steps 0 and 1 need compensation
// 	err := strategy.Compensate(context.Background(), steps, 2, data, logger)

// 	if err != nil {
// 		t.Errorf("Expected no error, got: %v", err)
// 	}

// 	if step1.compensateCalls != 1 {
// 		t.Errorf("Expected step1 compensated once, got %d", step1.compensateCalls)
// 	}

// 	if step2.compensateCalls != 1 {
// 		t.Errorf("Expected step2 compensated once, got %d", step2.compensateCalls)
// 	}
// }

// func TestRetryStrategy_EventualSuccess(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	// Step fails twice, then succeeds
// 	step1 := newMockStep("Step1", 2) // Fail first 2 attempts

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      3,
// 		InitialBackoff:  10 * time.Millisecond,
// 		MaxBackoff:      100 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewRetryStrategy[TestData](config)

// 	err := strategy.Compensate(context.Background(), steps, 1, data, logger)

// 	if err != nil {
// 		t.Errorf("Expected no error after retries, got: %v", err)
// 	}

// 	if step1.compensateCalls != 3 {
// 		t.Errorf("Expected 3 compensation attempts, got %d", step1.compensateCalls)
// 	}

// 	if data.StepResults["Step1"] != "compensated" {
// 		t.Errorf("Expected step1 to be compensated")
// 	}
// }

// func TestRetryStrategy_ExhaustedRetries(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	// Step always fails
// 	step1 := newMockStep("Step1", 999) // Always fails

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      3,
// 		InitialBackoff:  10 * time.Millisecond,
// 		MaxBackoff:      100 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewRetryStrategy[TestData](config)

// 	err := strategy.Compensate(context.Background(), steps, 1, data, logger)

// 	if err == nil {
// 		t.Error("Expected error after exhausting retries")
// 	}

// 	expectedAttempts := config.MaxRetries + 1 // Initial attempt + retries
// 	if step1.compensateCalls != expectedAttempts {
// 		t.Errorf("Expected %d compensation attempts, got %d", expectedAttempts, step1.compensateCalls)
// 	}

// 	if !strings.Contains(err.Error(), "after 4 attempts") {
// 		t.Errorf("Error should mention number of attempts: %v", err)
// 	}
// }

// func TestRetryStrategy_StopsOnFirstFailure(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	// First step fails, second should not be attempted
// 	step1 := newMockStep("Step1", 999) // Always fails
// 	step2 := newMockStep("Step2", 0)   // Would succeed

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 		step2.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      2,
// 		InitialBackoff:  10 * time.Millisecond,
// 		MaxBackoff:      100 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewRetryStrategy[TestData](config)

// 	// Steps 0 and 1 were executed, so both need compensation
// 	err := strategy.Compensate(context.Background(), steps, 2, data, logger)

// 	if err == nil {
// 		t.Error("Expected error from failed compensation")
// 	}

// 	// Step2 should be attempted but step1 should fail and stop compensation
// 	if step2.compensateCalls != 1 {
// 		t.Errorf("Expected step2 to be compensated once, got %d", step2.compensateCalls)
// 	}

// 	// Step1 should have exhausted retries
// 	if step1.compensateCalls != 3 { // Initial + 2 retries
// 		t.Errorf("Expected step1 to have 3 attempts, got %d", step1.compensateCalls)
// 	}
// }

// func TestRetryStrategy_ContextCancellation(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 999) // Always fails

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      10,
// 		InitialBackoff:  50 * time.Millisecond,
// 		MaxBackoff:      500 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewRetryStrategy[TestData](config)

// 	ctx, cancel := context.WithCancel(context.Background())
// 	cancel() // Cancel immediately

// 	err := strategy.Compensate(ctx, steps, 1, data, logger)

// 	if err == nil {
// 		t.Error("Expected error from context cancellation")
// 	}

// 	if !strings.Contains(err.Error(), "context") {
// 		t.Errorf("Error should mention context cancellation: %v", err)
// 	}
// }

// // =====================================
// // Tests for ContinueAllStrategy
// // =====================================

// func TestContinueAllStrategy_AllSucceed(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 0)
// 	step2 := newMockStep("Step2", 0)

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 		step2.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := DefaultRetryConfig()
// 	strategy := NewContinueAllStrategy[TestData](config)

// 	err := strategy.Compensate(context.Background(), steps, 2, data, logger)

// 	if err != nil {
// 		t.Errorf("Expected no error when all succeed, got: %v", err)
// 	}

// 	if data.StepResults["Step1"] != "compensated" || data.StepResults["Step2"] != "compensated" {
// 		t.Error("Expected both steps to be compensated")
// 	}
// }

// func TestContinueAllStrategy_ContinuesAfterFailure(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 999) // Always fails
// 	step2 := newMockStep("Step2", 0)   // Succeeds

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 		step2.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      2,
// 		InitialBackoff:  10 * time.Millisecond,
// 		MaxBackoff:      100 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewContinueAllStrategy[TestData](config)

// 	err := strategy.Compensate(context.Background(), steps, 2, data, logger)

// 	// Should return error but continue compensating
// 	if err == nil {
// 		t.Error("Expected error to be returned")
// 	}

// 	// Check it's a CompensationError
// 	compErr, ok := IsCompensationError(err)
// 	if !ok {
// 		t.Errorf("Expected CompensationError, got: %T", err)
// 	}

// 	if len(compErr.Failures) != 1 {
// 		t.Errorf("Expected 1 failure, got %d", len(compErr.Failures))
// 	}

// 	if compErr.Failures[0].StepName != "Step1" {
// 		t.Errorf("Expected Step1 to fail, got %s", compErr.Failures[0].StepName)
// 	}

// 	// Step2 should still be compensated despite Step1 failing
// 	if data.StepResults["Step2"] != "compensated" {
// 		t.Error("Expected Step2 to be compensated despite Step1 failure")
// 	}

// 	// Step1 should have tried with retries
// 	if step1.compensateCalls != 3 { // Initial + 2 retries
// 		t.Errorf("Expected 3 attempts for Step1, got %d", step1.compensateCalls)
// 	}
// }

// func TestContinueAllStrategy_MultipleFailures(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 999) // Always fails
// 	step2 := newMockStep("Step2", 999) // Always fails
// 	step3 := newMockStep("Step3", 0)   // Succeeds

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 		step2.toSagaStep(),
// 		step3.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      1,
// 		InitialBackoff:  10 * time.Millisecond,
// 		MaxBackoff:      100 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewContinueAllStrategy[TestData](config)

// 	err := strategy.Compensate(context.Background(), steps, 3, data, logger)

// 	if err == nil {
// 		t.Error("Expected error when multiple steps fail")
// 	}

// 	compErr, ok := IsCompensationError(err)
// 	if !ok {
// 		t.Fatalf("Expected CompensationError, got: %T", err)
// 	}

// 	if len(compErr.Failures) != 2 {
// 		t.Errorf("Expected 2 failures, got %d", len(compErr.Failures))
// 	}

// 	// Verify both failed steps are reported
// 	failedNames := map[string]bool{}
// 	for _, failure := range compErr.Failures {
// 		failedNames[failure.StepName] = true
// 	}

// 	if !failedNames["Step1"] || !failedNames["Step2"] {
// 		t.Error("Expected Step1 and Step2 to be in failures")
// 	}

// 	// Step3 should still succeed
// 	if data.StepResults["Step3"] != "compensated" {
// 		t.Error("Expected Step3 to be compensated")
// 	}
// }

// func TestContinueAllStrategy_CompensationErrorDetails(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 999)

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      2,
// 		InitialBackoff:  10 * time.Millisecond,
// 		MaxBackoff:      100 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewContinueAllStrategy[TestData](config)

// 	err := strategy.Compensate(context.Background(), steps, 1, data, logger)

// 	compErr, ok := IsCompensationError(err)
// 	if !ok {
// 		t.Fatalf("Expected CompensationError")
// 	}

// 	result := compErr.Failures[0]
// 	if result.StepName != "Step1" {
// 		t.Errorf("Expected StepName to be Step1, got %s", result.StepName)
// 	}

// 	if result.Success {
// 		t.Error("Expected Success to be false")
// 	}

// 	if result.Error == nil {
// 		t.Error("Expected Error to be set")
// 	}

// 	if result.Attempts != 3 { // Initial + 2 retries
// 		t.Errorf("Expected Attempts to be 3, got %d", result.Attempts)
// 	}

// 	// Check error message format
// 	errMsg := compErr.Error()
// 	if !strings.Contains(errMsg, "Step1") {
// 		t.Errorf("Error message should contain step name: %s", errMsg)
// 	}

// 	if !strings.Contains(errMsg, "attempts: 3") {
// 		t.Errorf("Error message should contain attempt count: %s", errMsg)
// 	}
// }

// // =====================================
// // Tests for FailFastStrategy
// // =====================================

// func TestFailFastStrategy_AllSucceed(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 0)
// 	step2 := newMockStep("Step2", 0)

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 		step2.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	strategy := NewFailFastStrategy[TestData]()

// 	err := strategy.Compensate(context.Background(), steps, 2, data, logger)

// 	if err != nil {
// 		t.Errorf("Expected no error, got: %v", err)
// 	}

// 	if step1.compensateCalls != 1 || step2.compensateCalls != 1 {
// 		t.Error("Expected both steps to be compensated once")
// 	}
// }

// func TestFailFastStrategy_StopsImmediately(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 1) // Fails once
// 	step2 := newMockStep("Step2", 0) // Would succeed

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 		step2.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	strategy := NewFailFastStrategy[TestData]()

// 	err := strategy.Compensate(context.Background(), steps, 2, data, logger)

// 	if err == nil {
// 		t.Error("Expected error from failed compensation")
// 	}

// 	// Step1 should be attempted only once (no retries)
// 	if step1.compensateCalls != 1 {
// 		t.Errorf("Expected step1 to be attempted once, got %d", step1.compensateCalls)
// 	}

// 	// Step2 should still be attempted (it comes before Step1 in reverse order)
// 	if step2.compensateCalls != 1 {
// 		t.Errorf("Expected step2 to be attempted once, got %d", step2.compensateCalls)
// 	}

// 	if !strings.Contains(err.Error(), "Step1") {
// 		t.Errorf("Error should mention failed step: %v", err)
// 	}
// }

// func TestFailFastStrategy_NoRetries(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 999) // Always fails

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	strategy := NewFailFastStrategy[TestData]()

// 	err := strategy.Compensate(context.Background(), steps, 1, data, logger)

// 	if err == nil {
// 		t.Error("Expected error")
// 	}

// 	// Should only attempt once - no retries
// 	if step1.compensateCalls != 1 {
// 		t.Errorf("Expected single attempt, got %d", step1.compensateCalls)
// 	}
// }

// // =====================================
// // Integration Tests
// // =====================================

// func TestCompensationInReverseOrder(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	// Test that all strategies compensate in reverse order
// 	executionOrder := []string{}

// 	step1 := &SagaStep[TestData]{
// 		Name:    "Step1",
// 		Execute: func(ctx context.Context, data *TestData) error { return nil },
// 		Compensate: func(ctx context.Context, data *TestData) error {
// 			executionOrder = append(executionOrder, "Step1")
// 			return nil
// 		},
// 	}

// 	step2 := &SagaStep[TestData]{
// 		Name:    "Step2",
// 		Execute: func(ctx context.Context, data *TestData) error { return nil },
// 		Compensate: func(ctx context.Context, data *TestData) error {
// 			executionOrder = append(executionOrder, "Step2")
// 			return nil
// 		},
// 	}

// 	step3 := &SagaStep[TestData]{
// 		Name:    "Step3",
// 		Execute: func(ctx context.Context, data *TestData) error { return nil },
// 		Compensate: func(ctx context.Context, data *TestData) error {
// 			executionOrder = append(executionOrder, "Step3")
// 			return nil
// 		},
// 	}

// 	steps := []*SagaStep[TestData]{step1, step2, step3}
// 	data := &TestData{StepResults: make(map[string]string)}

// 	strategies := []CompensationStrategy[TestData]{
// 		NewFailFastStrategy[TestData](),
// 		NewRetryStrategy[TestData](DefaultRetryConfig()),
// 		NewContinueAllStrategy[TestData](DefaultRetryConfig()),
// 	}

// 	for i, strategy := range strategies {
// 		executionOrder = []string{}
// 		// failedStepIndex=3 means steps 0, 1, 2 were executed and need compensation
// 		err := strategy.Compensate(context.Background(), steps, 3, data, logger)
// 		if err != nil {
// 			t.Errorf("Strategy %d failed: %v", i, err)
// 		}

// 		// Should compensate in reverse: Step3, Step2, Step1
// 		expected := []string{"Step3", "Step2", "Step1"}
// 		if len(executionOrder) != len(expected) {
// 			t.Errorf("Strategy %d: wrong number of compensations. Got %v, expected %v", i, executionOrder, expected)
// 			continue
// 		}

// 		for j, step := range expected {
// 			if executionOrder[j] != step {
// 				t.Errorf("Strategy %d: wrong order at index %d. Got %s, expected %s", i, j, executionOrder[j], step)
// 			}
// 		}
// 	}
// }

// func TestExponentialBackoff(t *testing.T) {
// 	logger := NewDefaultLogger(log.Default())
// 	step1 := newMockStep("Step1", 2) // Fails first 2 times

// 	steps := []*SagaStep[TestData]{
// 		step1.toSagaStep(),
// 	}

// 	data := &TestData{
// 		StepResults: make(map[string]string),
// 	}

// 	config := RetryConfig{
// 		MaxRetries:      3,
// 		InitialBackoff:  50 * time.Millisecond,
// 		MaxBackoff:      500 * time.Millisecond,
// 		BackoffMultiple: 2.0,
// 	}

// 	strategy := NewRetryStrategy[TestData](config)

// 	start := time.Now()
// 	err := strategy.Compensate(context.Background(), steps, 1, data, logger)
// 	duration := time.Since(start)

// 	if err != nil {
// 		t.Errorf("Expected success after retries, got: %v", err)
// 	}

// 	// Should take at least: 50ms + 100ms = 150ms (first two backoffs)
// 	// Allow some margin for execution time
// 	minDuration := 140 * time.Millisecond
// 	if duration < minDuration {
// 		t.Errorf("Expected backoff delays. Duration: %v, expected at least %v", duration, minDuration)
// 	}
// }

// func TestIsCompensationError(t *testing.T) {
// 	// Test with CompensationError
// 	compErr := &CompensationError{
// 		Message: "test",
// 		Failures: []CompensationResult{
// 			{StepName: "Step1", Success: false, Error: errors.New("fail"), Attempts: 3},
// 		},
// 	}

// 	result, ok := IsCompensationError(compErr)
// 	if !ok {
// 		t.Error("Expected IsCompensationError to return true for CompensationError")
// 	}
// 	if result != compErr {
// 		t.Error("Expected same error to be returned")
// 	}

// 	// Test with regular error
// 	regularErr := errors.New("regular error")
// 	_, ok = IsCompensationError(regularErr)
// 	if ok {
// 		t.Error("Expected IsCompensationError to return false for regular error")
// 	}
// }
